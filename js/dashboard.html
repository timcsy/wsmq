<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/vuetify@3.1.9/dist/vuetify.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.1.9/dist/vuetify.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .content {
      padding: 8px;
      transition: margin-left 0.3s ease;
      min-height: 100vh;
      margin-top: 48px;
      position: relative;
      overflow: hidden;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      margin: 2px 0;
    }

    .checkbox-label input {
      margin-right: 8px;
    }

    .draggable-window {
      position: absolute;
      border: 1px solid #ccc;
      background: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      resize: both;
      overflow: hidden;
      border-radius: 8px;
      min-height: 28px; /* 設置最小高度為標題列的高度 */
    }

    .window-title {
      background: linear-gradient(to bottom, #f0f0f0, #d0d0d0);
      color: black;
      padding: 8px;
      cursor: move;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .window-title-text {
      flex-grow: 1;
      text-align: left;
      padding-left: 8px;
    }

    .window-content {
      padding: 8px;
      overflow: auto;
      height: calc(100% - 28px);
    }

    .drawer-content {
      padding: 8px;
      overflow: auto;
      flex-grow: 1;
    }

    .window-buttons {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .window-button {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .window-button i {
      font-size: 2px;
      color: black;
    }

    .window-button.close {
      background-color: #ff5f57;
    }

    .window-button.minimize {
      background-color: #ffbd2e;
    }

    .window-button.maximize {
      background-color: #28c840;
    }

    .tab-button {
      color: white;
      text-transform: none;
      display: flex;
      align-items: center;
    }

    .tab-button.active {
      background-color: white;
      color: black;
    }

    .tab-close {
      margin-left: 8px;
    }
  </style>
</head>

<body>
  <div id="app"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
  <script type="module">
    const { createApp, defineComponent, ref, reactive, onMounted, watch, nextTick } = Vue
    const { createVuetify, useDisplay } = Vuetify

    import { ImageStream } from './image_stream.js'
    import { tensorComponent } from './tensor.js'

    const vuetify = createVuetify()
    const DRAWER_WIDTH = 256 // Drawer width constant

    const TreeNode = defineComponent({
      name: 'TreeNode',
      props: {
        node: Object,
        path: String,
        checkedPaths: Array,
        topics: Object
      },
      data() {
        return {
          checked: false
        }
      },
      watch: {
        checked(newVal) {
          this.$emit('select', this.path, newVal)
        },
        checkedPaths: {
          handler(newVal) {
            this.checked = newVal.includes(this.path)
          },
          immediate: true
        }
      },
      methods: {
        handleChildSelect(childPath, checked) {
          this.$emit('select', childPath, checked)
        },
        toggleCheckbox(event) {
          this.checked = event.target.checked
        },
        isDisabled(path) {
          return !this.topics.hasOwnProperty(path)
        }
      },
      template: `
        <div>
          <label class="checkbox-label">
            <input type="checkbox" :disabled="isDisabled(path)" v-model="checked" @change="toggleCheckbox">
            {{ node.name }}
          </label>
          <div v-if="node.children" style="margin-left: 16px;">
            <tree-node 
              v-for="child in node.children" 
              :key="child.id" 
              :node="child" 
              :path="path + '/' + child.name" 
              :checkedPaths="checkedPaths"
              :topics="topics"
              @select="handleChildSelect" 
            />
          </div>
        </div>
      `
    })

    const DraggableWindow = defineComponent({
      name: 'DraggableWindow',
      props: {
        title: String,
        windowId: String,
        windowZIndex: Number,
        position: Object,
        drawerOpen: Boolean
      },
      setup(props, { emit }) {
        const isManuallyResized = ref(false)
        const windowRef = ref(null)
        const maximized = ref(false)
        const minimized = ref(false)
        const originalSize = ref({})
        let minWidth
        let hasMousedown

        const setMinWidth = () => {
          const titleDiv = windowRef.value.querySelector('.window-title')
          const buttonsWidth = titleDiv.querySelector('.window-buttons').offsetWidth
          const titleWidth = titleDiv.querySelector('.window-title-text').offsetWidth
          minWidth = buttonsWidth + titleWidth + 16
          windowRef.value.style.minWidth = `${minWidth}px`
        }

        onMounted(() => {
          const el = windowRef.value
          el.style.left = `${props.position.left}px`
          el.style.top = `${props.position.top}px`

          let startX, startY, initialX, initialY

          const onMouseMove = (event) => {
            const dx = event.clientX - startX
            const dy = event.clientY - startY
            let newX = initialX + dx
            let newY = initialY + dy

            const parentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
            const elRect = el.getBoundingClientRect()
            const toolbarHeight = 48
            const drawerWidth = props.drawerOpen ? DRAWER_WIDTH : 0

            if (newY < 0) {
              newY = 0
            }
            if (newX < drawerWidth) {
              newX = drawerWidth
            }
            if (newX + elRect.width > parentRect.width) {
              newX = parentRect.width - elRect.width
            }
            if (newY + elRect.height > parentRect.height - toolbarHeight) {
              newY = parentRect.height - elRect.height - toolbarHeight
            }

            el.style.left = `${newX}px`
            el.style.top = `${newY}px`
          }

          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove)
            document.removeEventListener('mouseup', onMouseUp)
          }

          el.querySelector('.window-title').addEventListener('mousedown', (event) => {
            startX = event.clientX
            startY = event.clientY
            initialX = el.offsetLeft
            initialY = el.offsetTop

            document.addEventListener('mousemove', onMouseMove)
            document.addEventListener('mouseup', onMouseUp)

            event.preventDefault()
          })

          el.addEventListener('mousedown', () => {
            hasMousedown = true
            emit('focus', props.windowId)
          })

          el.ondragstart = () => false

          setMinWidth()

          nextTick(() => {
            const contentEl = el.querySelector('.window-content')
            if (contentEl) {
              const contentRect = contentEl.getBoundingClientRect()
              el.style.width = `${contentRect.width + 20}px`
              el.style.height = `${contentRect.height + 56}px`
            }
          })
        })

        watch(() => props.windowZIndex, (newZIndex) => {
          windowRef.value.style.zIndex = newZIndex
        })

        const toggleMaximize = () => {
          isManuallyResized.value = true
          const el = windowRef.value
          const contentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
          const drawerWidth = props.drawerOpen ? DRAWER_WIDTH : 0

          if (maximized.value) {
            el.style.width = originalSize.value.width
            el.style.height = originalSize.value.height
            el.style.left = originalSize.value.left
            el.style.top = originalSize.value.top
          } else {
            originalSize.value = {
              width: el.style.width,
              height: el.style.height,
              left: el.style.left,
              top: el.style.top
            }

            el.style.width = `${contentRect.width - drawerWidth}px`
            el.style.height = `${contentRect.height - 48}px`
            el.style.left = `${drawerWidth}px`
            el.style.top = '0px'
          }

          maximized.value = !maximized.value
          emit('focus', props.windowId)
        }

        const toggleMinimize = () => {
          const el = windowRef.value

          if (minimized.value) {
            el.style.width = originalSize.value.width
            el.style.height = originalSize.value.height
            el.style.left = originalSize.value.left
            el.style.top = originalSize.value.top
          } else {
            originalSize.value = {
              width: el.style.width,
              height: el.style.height,
              left: el.style.left,
              top: el.style.top
            }
          }

          minimized.value = !minimized.value
          emit('focus', props.windowId)
        }

        const onWindowResize = (entries) => {
          if (hasMousedown) isManuallyResized.value = true
          for (let entry of entries) {
            const el = entry.target
            const parentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
            const toolbarHeight = 48

            if (el.offsetHeight + el.offsetTop > parentRect.height - toolbarHeight) {
              el.style.height = `${parentRect.height - toolbarHeight - el.offsetTop}px`
            }
          }
          hasMousedown = false
        }

        const onContentResize = (entries) => {
          for (let entry of entries) {
            const contentEl = entry.target // window content
            const el = contentEl.parentElement // whole

            if (!isManuallyResized.value) {
              const contentChildren = Array.from(contentEl.children)
              // Initialize width and height
              let contentWidth = 0
              let contentHeight = 0
              // Iterate through all child elements to calculate total width and height
              contentChildren.forEach(child => {
                const childRect = child.getBoundingClientRect()
                contentWidth = Math.max(contentWidth, childRect.right - contentEl.getBoundingClientRect().left)
                contentHeight = Math.max(contentHeight, childRect.bottom - contentEl.getBoundingClientRect().top)
              })

              // Ensure the new dimensions do not exceed parent boundaries
              const padding = 8
              let newWidth = contentWidth + padding + 2 // 2: border line
              let newHeight = contentHeight + padding + 28 + 2 // 28: title height, 2: border line
              const parentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
              const toolbarHeight = 48
              const drawerWidth = props.drawerOpen ? DRAWER_WIDTH : 0
              if (el.offsetTop + newHeight > parentRect.height - toolbarHeight) {
                newHeight = parentRect.height - toolbarHeight - el.offsetTop
              }
              if (el.offsetLeft + newWidth > parentRect.width - drawerWidth) {
                newWidth = parentRect.width - drawerWidth - el.offsetLeft
              }
              el.style.width = `${newWidth}px`
              el.style.height = `${newHeight}px`
            } else {
              const canvas = el.querySelector('canvas')
              if (canvas) {
                const innerSize = entry.contentRect
                const scaleFactor = Math.min(innerSize.width / canvas.width, innerSize.height / canvas.height)
                canvas.style.width = `${canvas.width * scaleFactor}px`
                canvas.style.height = `${canvas.height * scaleFactor}px`
              }
            }
          }
        }

        const windowResizeObserver = new ResizeObserver(onWindowResize)
        const contentResizeObserver = new ResizeObserver(onContentResize)

        const mutationObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            // Force a resize calculation when content changes
            let contentEl = mutation.target
            while (contentEl && contentEl.className !== 'window-content') {
              contentEl = contentEl.parentElement
            }
            if (contentEl) {
              contentResizeObserver.unobserve(contentEl)
              contentResizeObserver.observe(contentEl)
            }
          })
        })

        onMounted(() => {
          const el = windowRef.value
          windowResizeObserver.observe(el)
          const contentEl = el.querySelector('.window-content')
          if (contentEl) {
            contentResizeObserver.observe(contentEl)
            mutationObserver.observe(contentEl, { attributes: true, childList: true, subtree: true, characterData: true })
          }
        })

        return {
          isManuallyResized,
          windowRef,
          toggleMaximize,
          toggleMinimize,
          minimized
        }
      },
      methods: {
        closeWindow() {
          this.$emit('close', this.windowId)
        },
        minimizeWindow() {
          this.toggleMinimize()
          this.$emit('minimize', this.windowId)
        },
        maximizeWindow() {
          this.toggleMaximize()
        }
      },
      template: `
        <div v-show="!minimized" class="draggable-window" ref="windowRef" :style="{ zIndex: windowZIndex }">
          <div class="window-title">
            <div class="window-buttons">
              <div class="window-button close" @click="closeWindow"><i class="fas fa-times"></i></div>
              <div class="window-button minimize" @click="minimizeWindow"><i class="fas fa-minus"></i></div>
              <div class="window-button maximize" @click="maximizeWindow"><i class="fas fa-expand"></i></div>
            </div>
            <div class="window-title-text">{{ title }}</div>
          </div>
          <div class="window-content"></div>
        </div>
      `
    })

    const DashboardView = defineComponent({
      components: {
        'tree-node': TreeNode,
        'draggable-window': DraggableWindow
      },
      props: {
        drawerOpen: Boolean,
        topics: Object,
        messageQueues: Object
      },
      setup(props) {
        const { mdAndUp, mdAndDown } = useDisplay()
        const drawerOpen = ref(props.drawerOpen)

        watch(() => props.drawerOpen, (newVal) => {
          drawerOpen.value = newVal
        })

        return {
          mdAndUp,
          mdAndDown,
          drawerOpen
        }
      },
      data() {
        return {
          treeData: [],
          windows: [],
          windowOrder: [],
          checkedPaths: []
        }
      },
      watch: {
        topics: {
          handler(newTopics) {
            this.updateTreeData(newTopics)
          },
          immediate: true
        },
        drawerOpen(newVal, oldVal) {
          this.adjustWindowPositionsForDrawer(newVal, oldVal)
        }
      },
      methods: {
        updateTreeData(topics) {
          const tree = {}
          Object.keys(topics).forEach(topic => {
            const parts = topic.split('/')
            let current = tree
            parts.forEach(part => {
              if (!current[part]) {
                current[part] = { children: {} }
              }
              current = current[part].children
            })
          })
          this.treeData = this.convertTreeData(tree)
        },
        convertTreeData(tree, parentPath = '') {
          return Object.keys(tree).map(key => {
            const fullPath = parentPath ? `${parentPath}/${key}` : key
            return {
              id: fullPath,
              name: key,
              children: this.convertTreeData(tree[key].children, fullPath)
            }
          })
        },
        updateSelectedPaths(path, checked) {
          const windowId = path
          const { left, top, width, height } = this.findNewWindowPosition()
          if (checked) {
            if (!this.checkedPaths.includes(path)) {
              this.checkedPaths.push(path)
            }
            const existingWindow = this.windows.find(w => w.id === windowId)
            if (existingWindow) {
              this.$refs[`window-${windowId}`][0].toggleMinimize()
            } else {
              this.windows.push({
                id: windowId,
                title: path,
                minimized: false,
                position: { left, top, width, height }
              })
              this.windowOrder.push(windowId)

              const topicObj = this.topics[path]
              if (topicObj) {
                let content
                switch (topicObj.type) {
                  case 'text':
                    content = this.displayText(this.messageQueues.mq, path)
                    break
                  case 'tensor':
                    content = this.displayTensor(this.messageQueues.mq, path)
                    break
                  case 'image':
                    content = this.displayImage(this.messageQueues.stream, path)
                    break
                }
                this.$nextTick(() => {
                  const windowComponent = this.$refs[`window-${windowId}`]
                  if (windowComponent && windowComponent.length > 0) {
                    const windowContent = windowComponent[0].$el.querySelector('.window-content')
                    if (windowContent) {
                      windowContent.innerHTML = ''
                      windowContent.appendChild(content)
                    }
                  }
                })
              }
            }
            this.handleWindowFocus(windowId)
          } else {
            this.checkedPaths = this.checkedPaths.filter(p => p !== path)
            const windowToMinimize = this.$refs[`window-${windowId}`][0]
            if (windowToMinimize) {
              windowToMinimize.toggleMinimize()
            }
          }
        },
        getNodePath(node) {
          const path = []
          let current = node
          while (current) {
            path.unshift(current.name)
            current = this.findParent(this.treeData, current)
          }
          return path.join('/')
        },
        findParent(nodes, target) {
          for (let node of nodes) {
            if (node.children && node.children.includes(target)) {
              return node
            }
            if (node.children) {
              const parent = this.findParent(node.children, target)
              if (parent) {
                return parent
              }
            }
          }
          return null
        },
        handleWindowFocus(windowId) {
          this.windowOrder = this.windowOrder.filter(id => id !== windowId)
          this.windowOrder.push(windowId)
        },
        getWindowZIndex(windowId) {
          return this.windowOrder.indexOf(windowId) + 1000
        },
        closeWindow(windowId) {
          this.windows = this.windows.filter(w => w.id !== windowId)
          this.windowOrder = this.windowOrder.filter(id => id !== windowId)
          this.checkedPaths = this.checkedPaths.filter(path => path !== windowId)
        },
        minimizeWindow(windowId) {
          this.$refs[`window-${windowId}`][0].toggleMinimize()
          this.checkedPaths = this.checkedPaths.filter(path => path !== windowId)
        },
        maximizeWindow(windowId) {
          this.$refs[`window-${windowId}`][0].toggleMaximize()
        },
        findNewWindowPosition() {
          const margin = 10
          const defaultWidth = 300
          const defaultHeight = 200
          const containerRect = this.$refs.content ? this.$refs.content.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
          const drawerOpen = this.drawerOpen
          const drawerWidth = drawerOpen ? DRAWER_WIDTH : 0

          let left = margin + drawerWidth
          let top = margin
          let width = defaultWidth
          let height = defaultHeight
          let maxAttempts = 100

          while (maxAttempts > 0 && this.windows.some(w => this.isOverlapping(left, top, width, height, w.position))) {
            left += margin
            top += margin

            if (left + width > containerRect.width) {
              left = margin + drawerWidth
            }
            if (top + height > containerRect.height) {
              top = margin
            }

            maxAttempts--
          }

          if (maxAttempts === 0) {
            let minOverlap = Number.MAX_VALUE
            let bestPosition = { left, top, width, height }

            for (let i = 0; i < containerRect.width - width; i += margin) {
              for (let j = 0; j < containerRect.height - height; j += margin) {
                let overlap = this.calculateTotalOverlap(i, j, width, height)
                if (overlap < minOverlap) {
                  minOverlap = overlap
                  bestPosition = { left: i + drawerWidth, top: j, width, height }
                }
              }
            }

            return bestPosition
          }

          return { left, top, width, height }
        },
        adjustWindowPositionsForDrawer(newDrawerOpen, oldDrawerOpen) {
          const drawerWidth = newDrawerOpen ? DRAWER_WIDTH : 0
          this.windows.forEach(window => {
            const windowRef = this.$refs[`window-${window.id}`][0]
            if (windowRef) {
              if (newDrawerOpen && windowRef.offsetLeft < drawerWidth) {
                windowRef.style.left = `${drawerWidth}px`
              }
              if (!newDrawerOpen && windowRef.offsetLeft < DRAWER_WIDTH) {
                windowRef.style.left = `${windowRef.offsetLeft - DRAWER_WIDTH}px`
              }
            }
          })
        },
        isOverlapping(left, top, width, height, position) {
          return !(
            left + width < position.left ||
            left > position.left + position.width ||
            top + height < position.top ||
            top > position.top + position.height
          )
        },
        calculateTotalOverlap(left, top, width, height) {
          let totalOverlap = 0
          this.windows.forEach(w => {
            totalOverlap += this.calculateOverlap(left, top, width, height, w.position)
          })
          return totalOverlap
        },
        calculateOverlap(left, top, width, height, position) {
          const x_overlap = Math.max(0, Math.min(left + width, position.left + position.width) - Math.max(left, position.left))
          const y_overlap = Math.max(0, Math.min(top + height, position.top + position.height) - Math.max(top, position.top))
          return x_overlap * y_overlap
        },
        displayText(mq, topic) {
          const text = document.createElement('div')
          text.style.display = `inline-block`
          text.style.whiteSpace = `nowrap`
          mq.subscribe(topic, (topic, payload, props) => {
            text.innerText = payload
          })
          return text
        },
        displayTensor(mq, topic) {
          const tensor = document.createElement('div')
          tensor.style.display = `inline-block`
          tensor.style.whiteSpace = `nowrap`
          mq.subscribe(topic, (topic, payload, props) => {
            tensor.innerHTML = tensorComponent(payload)
          })
          return tensor
        },
        displayImage(stream, topic) {
          const canvas = document.createElement('canvas')
          stream.displayImage(topic, canvas)
          return canvas
        }
      },
      computed: {
        contentClasses() {
          return {
            'drawer-open': this.mdAndUp && this.drawerOpen
          }
        }
      },
      template: `
        <div>
          <v-navigation-drawer
            app
            v-model="drawerOpen"
          >
            <div class="drawer-content">
              <tree-node 
                v-for="item in treeData" 
                :key="item.id" 
                :node="item" 
                :path="item.id" 
                :checkedPaths="checkedPaths"
                :topics="topics"
                @select="updateSelectedPaths" 
              />
            </div>
          </v-navigation-drawer>
          <div :class="['content', contentClasses]" ref="content">
            <draggable-window
              v-for="window in windows"
              :key="window.id"
              :ref="'window-' + window.id"
              :title="window.title"
              :window-id="window.id"
              :window-z-index="getWindowZIndex(window.id)"
              :position="window.position"
              :drawer-open="drawerOpen"
              @focus="handleWindowFocus"
              @close="closeWindow"
              @minimize="minimizeWindow"
              @maximize="maximizeWindow"
            />
          </div>
        </div>
      `
    })

    const DashboardApp = defineComponent({
      components: { DashboardView },
      data() {
        return {
          currentTab: 'view1',
          tabCounter: 1,
          tabs: [
            { name: 'view1', drawerOpen: true, lastDrawerState: true, topics: [{ name: 'foo/bar', type: 'text' }, { name: 'foo/dev', type: 'text' }] }
          ],
          dialog: false,
          terminate: true,
          messageQueues: reactive({
            stream: null,
            mq: null
          })
        }
      },
      methods: {
        setCurrentTab(tabName) {
          this.tabs.forEach(tab => {
            if (tab.name === tabName) {
              tab.drawerOpen = tab.lastDrawerState
            } else {
              tab.drawerOpen = false
            }
          })
          this.currentTab = tabName
        },
        toggleDrawer() {
          const currentTab = this.tabs.find(tab => tab.name === this.currentTab)
          currentTab.drawerOpen = !currentTab.drawerOpen
          currentTab.lastDrawerState = currentTab.drawerOpen
        },
        addNewTab() {
          this.tabCounter++
          const newTabName = `view${this.tabCounter}`
          this.tabs.push({ name: newTabName, drawerOpen: true, lastDrawerState: true, topics: [] })
          this.setCurrentTab(newTabName)
        },
        closeTab(tabName) {
          const tabIdx = this.tabs.findIndex(tab => tab.name === tabName)
          if (tabIdx > -1) {
            this.tabs.splice(tabIdx, 1)
            if (this.currentTab === tabName) {
              this.currentTab = this.tabs.length ? this.tabs[0].name : ''
            }
          }
        },
        onDragEnd(evt) {
          const { oldIndex, newIndex } = evt
          const movedTab = this.tabs.splice(oldIndex, 1)[0]
          this.tabs.splice(newIndex, 0, movedTab)
        },
        openDialog() {
          this.dialog = true
        },
        addTopic() {
          const currentTab = this.tabs.find(tab => tab.name === this.currentTab)
          currentTab.topics.push({ name: '', type: 'text' })
        },
        async start() {
          this.terminate = false
          this.messageQueues.stream = new ImageStream('ws://localhost:6789', 1)
          this.messageQueues.mq = this.messageQueues.stream.client
          await this.messageQueues.stream.start()

          while (!this.terminate) {
            await new Promise(resolve => setTimeout(resolve, 33))
          }

          await this.messageQueues.stream.stop()
        },
        stop() {
          this.terminate = true
        }
      },
      mounted() {
        const el = this.$refs.tabContainer
        new Sortable(el, {
          animation: 150,
          onEnd: this.onDragEnd
        })
      },
      template: `
        <v-app>
          <v-app-bar app dense height="48" color="#333">
            <v-app-bar-nav-icon @click="toggleDrawer" style="color: white;"></v-app-bar-nav-icon>
            <div ref="tabContainer" style="display: flex; align-items: center;">
              <v-btn
                v-for="tab in tabs"
                :key="tab.name"
                text
                @click="setCurrentTab(tab.name)"
                :class="['tab-button', { 'active': currentTab === tab.name }]"
              >
                {{ tab.name.toUpperCase() }}
                <v-icon small class="tab-close" @click.stop="closeTab(tab.name)">mdi-close</v-icon>
              </v-btn>
              <v-btn icon @click="addNewTab" style="color: white;">
                <v-icon>mdi-plus</v-icon>
              </v-btn>
            </div>
            <v-spacer></v-spacer>
            <v-btn v-show="terminate" icon @click="start" style="color: white;">
              <v-icon>mdi-play</v-icon>
            </v-btn>
            <v-btn v-show="!terminate" icon @click="stop" style="color: white;">
              <v-icon>mdi-stop</v-icon>
            </v-btn>
            <v-btn icon @click="openDialog" style="color: white;">
              <v-icon>mdi-dots-vertical</v-icon>
            </v-btn>
          </v-app-bar>
          <v-dialog v-model="dialog" max-width="500px">
            <v-card>
              <v-card-title>Topics</v-card-title>
              <v-card-text>
                <v-container>
                  <v-row v-for="(topic, index) in tabs.find(tab => tab.name === currentTab).topics" :key="index">
                    <v-col cols="8">
                      <v-text-field v-model="tabs.find(tab => tab.name === currentTab).topics[index].name" label="Topic"></v-text-field>
                    </v-col>
                    <v-col cols="4">
                      <v-select v-model="tabs.find(tab => tab.name === currentTab).topics[index].type" :items="['text', 'tensor', 'image']" label="Type"></v-select>
                    </v-col>
                  </v-row>
                </v-container>
              </v-card-text>
              <v-card-actions>
                <v-btn @click="addTopic">
                  <v-icon left>mdi-plus</v-icon>
                  Add Topic
                </v-btn>
              </v-card-actions>
            </v-card>
          </v-dialog>
          <dashboard-view
            v-for="tab in tabs"
            :key="tab.name"
            :drawer-open="tab.drawerOpen"
            :topics="Object.fromEntries(tab.topics.map(topic => [topic.name, topic]))"
            :message-queues="messageQueues"
            v-show="currentTab === tab.name"
          ></dashboard-view>
        </v-app>
      `
    })

    createApp(DashboardApp).use(vuetify).mount('#app')
  </script>
</body>

</html>
