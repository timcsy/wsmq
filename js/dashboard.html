<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/vuetify@3.1.9/dist/vuetify.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.1.9/dist/vuetify.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .content {
      padding: 8px;
      transition: margin-left 0.3s ease;
      min-height: 100vh;
      margin-top: 48px;
      position: relative;
      overflow: hidden;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      margin: 2px 0;
    }

    .checkbox-label input {
      margin-right: 8px;
    }

    .draggable-window {
      position: absolute;
      border: 1px solid #ccc;
      background: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      resize: both;
      overflow: hidden;
      border-radius: 8px;
      min-height: 28px;
    }

    .window-title {
      background: linear-gradient(to bottom, #f0f0f0, #d0d0d0);
      color: black;
      padding: 8px;
      cursor: move;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .window-title-text {
      flex-grow: 1;
      text-align: left;
      padding-left: 8px;
    }

    .window-content {
      padding: 8px;
      overflow: auto;
      height: calc(100% - 28px);
    }

    .drawer-content {
      padding: 8px;
      overflow: auto;
      flex-grow: 1;
    }

    .window-buttons {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .window-button {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .window-button i {
      font-size: 2px;
      color: black;
    }

    .window-button.close {
      background-color: #ff5f57;
    }

    .window-button.minimize {
      background-color: #ffbd2e;
    }

    .window-button.maximize {
      background-color: #28c840;
    }

    .tab-button {
      color: white;
      text-transform: none;
      display: flex;
      align-items: center;
    }

    .tab-button.active {
      background-color: white;
      color: black;
    }

    .tab-close {
      margin-left: 8px;
    }
  </style>
</head>

<body>
  <div id="app"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
  <script type="module">
    const { createApp, defineComponent, ref, onMounted, watch, nextTick } = Vue
    const { createVuetify, useDisplay } = Vuetify

    import { ImageStream } from './image_stream.js'
    import { tensorComponent } from './tensor.js'

    const vuetify = createVuetify()
    const DRAWER_WIDTH = 256 // Drawer width constant

    const TreeNode = defineComponent({
      name: 'TreeNode',
      props: {
        node: Object,
        path: String,
        checkedPaths: Array,
        topics: Object,
        isRoot: Boolean
      },
      data() {
        return {
          checked: false
        }
      },
      watch: {
        checked(newVal) {
          this.$emit('select', this.path, newVal)
        },
        checkedPaths: {
          handler(newVal) {
            this.checked = newVal.includes(this.path)
          },
          immediate: true
        }
      },
      methods: {
        handleChildSelect(childPath, checked) {
          this.$emit('select', childPath, checked)
        },
        toggleCheckbox(event) {
          this.checked = event.target.checked
        },
        isDisabled(path) {
          return !this.topics.hasOwnProperty(path)
        }
      },
      template: `
        <div>
          <label class="checkbox-label" v-if="isRoot">
            {{ node.name }} ({{ node.url }})
          </label>
          <label class="checkbox-label" v-else>
            <input type="checkbox" :disabled="isDisabled(path)" v-model="checked" @change="toggleCheckbox">
            {{ node.name }}
          </label>
          <div v-if="node.children" style="margin-left: 16px;">
            <tree-node 
              v-for="child in node.children" 
              :key="child.id" 
              :node="child" 
              :path="path + '/' + child.name" 
              :checkedPaths="checkedPaths"
              :topics="topics"
              :is-root="false"
              @select="handleChildSelect" 
            />
          </div>
        </div>
      `
    })

    const DraggableWindow = defineComponent({
      name: 'DraggableWindow',
      props: {
        title: String,
        windowId: String,
        windowZIndex: Number,
        position: Object,
        drawerOpen: Boolean
      },
      setup(props, { emit }) {
        const isManuallyResized = ref(false)
        const windowRef = ref(null)
        const maximized = ref(false)
        const minimized = ref(false)
        const originalSize = ref({})
        let minWidth
        let hasMousedown

        const setMinWidth = () => {
          const titleDiv = windowRef.value.querySelector('.window-title')
          const buttonsWidth = titleDiv.querySelector('.window-buttons').offsetWidth
          const titleWidth = titleDiv.querySelector('.window-title-text').offsetWidth
          minWidth = buttonsWidth + titleWidth + 16
          windowRef.value.style.minWidth = `${minWidth}px`
        }

        onMounted(() => {
          const el = windowRef.value
          el.style.left = `${props.position.left}px`
          el.style.top = `${props.position.top}px`

          let startX, startY, initialX, initialY

          const onMouseMove = (event) => {
            const dx = event.clientX - startX
            const dy = event.clientY - startY
            let newX = initialX + dx
            let newY = initialY + dy

            const parentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
            const elRect = el.getBoundingClientRect()
            const toolbarHeight = 48
            const drawerWidth = props.drawerOpen ? DRAWER_WIDTH : 0

            if (newY < 0) {
              newY = 0
            }
            if (newX < drawerWidth) {
              newX = drawerWidth
            }
            if (newX + elRect.width > parentRect.width) {
              newX = parentRect.width - elRect.width
            }
            if (newY + elRect.height > parentRect.height - toolbarHeight) {
              newY = parentRect.height - elRect.height - toolbarHeight
            }

            el.style.left = `${newX}px`
            el.style.top = `${newY}px`
          }

          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove)
            document.removeEventListener('mouseup', onMouseUp)
          }

          el.querySelector('.window-title').addEventListener('mousedown', (event) => {
            startX = event.clientX
            startY = event.clientY
            initialX = el.offsetLeft
            initialY = el.offsetTop

            document.addEventListener('mousemove', onMouseMove)
            document.addEventListener('mouseup', onMouseUp)

            event.preventDefault()
          })

          el.addEventListener('mousedown', () => {
            hasMousedown = true
            emit('focus', props.windowId)
          })

          el.ondragstart = () => false

          setMinWidth()

          nextTick(() => {
            const contentEl = el.querySelector('.window-content')
            if (contentEl) {
              const contentRect = contentEl.getBoundingClientRect()
              el.style.width = `${contentRect.width + 20}px`
              el.style.height = `${contentRect.height + 56}px`
            }
          })
        })

        watch(() => props.windowZIndex, (newZIndex) => {
          windowRef.value.style.zIndex = newZIndex
        })

        const toggleMaximize = () => {
          isManuallyResized.value = true
          const el = windowRef.value
          const contentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
          const drawerWidth = props.drawerOpen ? DRAWER_WIDTH : 0

          if (maximized.value) {
            el.style.width = originalSize.value.width
            el.style.height = originalSize.value.height
            el.style.left = originalSize.value.left
            el.style.top = originalSize.value.top
          } else {
            originalSize.value = {
              width: el.style.width,
              height: el.style.height,
              left: el.style.left,
              top: el.style.top
            }

            el.style.width = `${contentRect.width - drawerWidth}px`
            el.style.height = `${contentRect.height - 48}px`
            el.style.left = `${drawerWidth}px`
            el.style.top = '0px'
          }

          maximized.value = !maximized.value
          emit('focus', props.windowId)
        }

        const toggleMinimize = () => {
          const el = windowRef.value

          if (minimized.value) {
            el.style.width = originalSize.value.width
            el.style.height = originalSize.value.height
            el.style.left = originalSize.value.left
            el.style.top = originalSize.value.top
          } else {
            originalSize.value = {
              width: el.style.width,
              height: el.style.height,
              left: el.style.left,
              top: el.style.top
            }
          }

          minimized.value = !minimized.value
          emit('focus', props.windowId)
        }

        const onWindowResize = (entries) => {
          if (hasMousedown) isManuallyResized.value = true
          for (let entry of entries) {
            const el = entry.target
            const parentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
            const toolbarHeight = 48

            if (el.offsetHeight + el.offsetTop > parentRect.height - toolbarHeight) {
              el.style.height = `${parentRect.height - toolbarHeight - el.offsetTop}px`
            }
          }
          hasMousedown = false
        }

        const onContentResize = (entries) => {
          for (let entry of entries) {
            const contentEl = entry.target // window content
            const el = contentEl.parentElement // whole

            if (!isManuallyResized.value) {
              const contentChildren = Array.from(contentEl.children)
              // Initialize width and height
              let contentWidth = 0
              let contentHeight = 0
              // Iterate through all child elements to calculate total width and height
              contentChildren.forEach(child => {
                const childRect = child.getBoundingClientRect()
                contentWidth = Math.max(contentWidth, childRect.right - contentEl.getBoundingClientRect().left)
                contentHeight = Math.max(contentHeight, childRect.bottom - contentEl.getBoundingClientRect().top)
              })

              // Ensure the new dimensions do not exceed parent boundaries
              const padding = 8
              let newWidth = contentWidth + padding + 2 // 2: border line
              let newHeight = contentHeight + padding + 28 + 2 // 28: title height, 2: border line
              const parentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
              const toolbarHeight = 48
              const drawerWidth = props.drawerOpen ? DRAWER_WIDTH : 0
              if (el.offsetTop + newHeight > parentRect.height - toolbarHeight) {
                newHeight = parentRect.height - toolbarHeight - el.offsetTop
              }
              if (el.offsetLeft + newWidth > parentRect.width - drawerWidth) {
                newWidth = parentRect.width - drawerWidth - el.offsetLeft
              }
              el.style.width = `${newWidth}px`
              el.style.height = `${newHeight}px`
            } else {
              const canvas = el.querySelector('canvas')
              if (canvas) {
                const innerSize = entry.contentRect
                const scaleFactor = Math.min(innerSize.width / canvas.width, innerSize.height / canvas.height)
                canvas.style.width = `${canvas.width * scaleFactor}px`
                canvas.style.height = `${canvas.height * scaleFactor}px`
              }
            }
          }
        }

        const windowResizeObserver = new ResizeObserver(onWindowResize)
        const contentResizeObserver = new ResizeObserver(onContentResize)

        const mutationObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            // Force a resize calculation when content changes
            let contentEl = mutation.target
            while (contentEl && contentEl.className !== 'window-content') {
              contentEl = contentEl.parentElement
            }
            if (contentEl) {
              contentResizeObserver.unobserve(contentEl)
              contentResizeObserver.observe(contentEl)
            }
          })
        })

        onMounted(() => {
          const el = windowRef.value
          windowResizeObserver.observe(el)
          const contentEl = el.querySelector('.window-content')
          if (contentEl) {
            contentResizeObserver.observe(contentEl)
            mutationObserver.observe(contentEl, { attributes: true, childList: true, subtree: true, characterData: true })
          }
        })

        return {
          isManuallyResized,
          windowRef,
          toggleMaximize,
          toggleMinimize,
          minimized
        }
      },
      methods: {
        closeWindow() {
          this.$emit('close', this.windowId)
        },
        minimizeWindow() {
          this.toggleMinimize()
          this.$emit('minimize', this.windowId)
        },
        maximizeWindow() {
          this.toggleMaximize()
        }
      },
      template: `
        <div v-show="!minimized" class="draggable-window" ref="windowRef" :style="{ zIndex: windowZIndex }">
          <div class="window-title">
            <div class="window-buttons">
              <div class="window-button close" @click="closeWindow"><i class="fas fa-times"></i></div>
              <div class="window-button minimize" @click="minimizeWindow"><i class="fas fa-minus"></i></div>
              <div class="window-button maximize" @click="maximizeWindow"><i class="fas fa-expand"></i></div>
            </div>
            <div class="window-title-text">{{ title }}</div>
          </div>
          <div class="window-content"></div>
        </div>
      `
    })

    const DashboardView = defineComponent({
      components: {
        'tree-node': TreeNode,
        'draggable-window': DraggableWindow
      },
      props: {
        drawerOpen: Boolean,
        brokers: Array
      },
      setup(props) {
        const { mdAndUp, mdAndDown } = useDisplay()
        const drawerOpen = ref(props.drawerOpen)

        watch(() => props.drawerOpen, (newVal) => {
          drawerOpen.value = newVal
        })

        return {
          mdAndUp,
          mdAndDown,
          drawerOpen
        }
      },
      data() {
        return {
          treeData: [],
          windows: [],
          windowOrder: [],
          checkedPaths: []
        }
      },
      watch: {
        brokers: {
          handler(newBrokers) {
            this.updateTreeData(newBrokers)
          },
          deep: true,
          immediate: true
        },
        drawerOpen(newVal, oldVal) {
          this.adjustWindowPositionsForDrawer(newVal, oldVal)
        }
      },
      methods: {
        updateTreeData(brokers) {
          const tree = {}
          brokers.forEach(broker => {
            broker.topics.forEach(topic => {
              const topicPath = `${broker.name}/${topic.name}`
              const parts = topicPath.split('/')
              let current = tree
              parts.forEach(part => {
                if (!current[part]) {
                  current[part] = { children: {} }
                }
                current = current[part].children
              })
            })
          })
          this.treeData = this.convertTreeData(tree, brokers)
        },
        convertTreeData(tree, brokers, parentPath = '') {
          return Object.keys(tree).map(key => {
            const fullPath = parentPath ? `${parentPath}/${key}` : key
            const broker = brokers.find(b => b.name === key)
            return {
              id: fullPath,
              name: key,
              url: broker ? broker.url : '',
              children: this.convertTreeData(tree[key].children, brokers, fullPath)
            }
          })
        },
        async updateSelectedPaths(path, checked) {
          const parts = path.split('/')
          const brokerAlias = parts[0]
          const topic = parts.slice(1).join('/')
          const broker = this.brokers.find(b => b.name === brokerAlias)
          if (broker) {
            if (checked) {
              if (!broker.isRunning) {
                broker.imageStream = new ImageStream(broker.url, 1)
                broker.client = broker.imageStream.client
                await broker.imageStream.start()
                broker.isRunning = true
              }
              const { left, top, width, height } = this.findNewWindowPosition()
              if (!this.checkedPaths.includes(path)) {
                this.checkedPaths.push(path)
              }
              const existingWindow = this.windows.find(w => w.id === path)
              if (existingWindow) {
                this.$refs[`window-${path}`][0].toggleMinimize()
              } else {
                this.windows.push({
                  id: path,
                  title: path,
                  brokerUrl: broker.url,
                  minimized: false,
                  position: { left, top, width, height }
                })
                this.windowOrder.push(path)

                this.$nextTick(() => {
                  const windowComponent = this.$refs[`window-${path}`]
                  if (windowComponent && windowComponent.length > 0) {
                    const windowContent = windowComponent[0].$el.querySelector('.window-content')
                    if (windowContent) {
                      windowContent.innerHTML = ''
                      const topicObj = broker.topics.find(t => t.name === topic)
                      if (topicObj) {
                        windowContent.appendChild(this.displayContent(broker, topicObj))
                      }
                    }
                  }
                })
              }
              this.handleWindowFocus(path)
            } else {
              this.checkedPaths = this.checkedPaths.filter(p => p !== path)
              const windowToMinimize = this.$refs[`window-${path}`][0]
              if (windowToMinimize) {
                windowToMinimize.toggleMinimize()
              }
            }
          }
        },
        displayContent(broker, topic) {
          if (topic.type === 'text') {
            return this.displayText(broker.client, topic.name)
          } else if (topic.type === 'tensor') {
            return this.displayTensor(broker.client, topic.name)
          } else if (topic.type === 'image') {
            return this.displayImage(broker.imageStream, topic.name)
          }
          return this.displayText(broker.client, topic.name)
        },
        displayText(mq, topic) {
          const text = document.createElement('div')
          text.style.display = `inline-block`
          text.style.whiteSpace = `nowrap`
          mq.subscribe(topic, (topic, payload, props) => {
            text.innerText = payload
          })
          return text
        },
        displayTensor(mq, topic) {
          const tensor = document.createElement('div')
          tensor.style.display = `inline-block`
          tensor.style.whiteSpace = `nowrap`
          mq.subscribe(topic, (topic, payload, props) => {
            tensor.innerHTML = tensorComponent(payload)
          })
          return tensor
        },
        displayImage(stream, topic) {
          const canvas = document.createElement('canvas')
          stream.displayImage(topic, canvas)
          return canvas
        },
        getNodePath(node) {
          const path = []
          let current = node
          while (current) {
            path.unshift(current.name)
            current = this.findParent(this.treeData, current)
          }
          return path.join('/')
        },
        findParent(nodes, target) {
          for (let node of nodes) {
            if (node.children && node.children.includes(target)) {
              return node
            }
            if (node.children) {
              const parent = this.findParent(node.children, target)
              if (parent) {
                return parent
              }
            }
          }
          return null
        },
        handleWindowFocus(windowId) {
          this.windowOrder = this.windowOrder.filter(id => id !== windowId)
          this.windowOrder.push(windowId)
        },
        getWindowZIndex(windowId) {
          return this.windowOrder.indexOf(windowId) + 1000
        },
        async closeWindow(windowId) {
          const currentWindow = this.windows.find(w => w.id === windowId)
          if (currentWindow) {
            const broker = this.brokers.find(b => b.url === currentWindow.brokerUrl)
            if (broker && broker.client) {
              const topic = windowId.split('/').slice(1).join('/')
              broker.client.unsubscribe(topic)
            }
          }
          this.windows = this.windows.filter(w => w.id !== windowId)
          this.windowOrder = this.windowOrder.filter(id => id !== windowId)
          this.checkedPaths = this.checkedPaths.filter(path => path !== windowId)
        },
        minimizeWindow(windowId) {
          this.$refs[`window-${windowId}`][0].toggleMinimize()
          this.checkedPaths = this.checkedPaths.filter(path => path !== windowId)
        },
        maximizeWindow(windowId) {
          this.$refs[`window-${windowId}`][0].toggleMaximize()
        },
        findNewWindowPosition() {
          const margin = 10
          const defaultWidth = 300
          const defaultHeight = 200
          const containerRect = this.$refs.content ? this.$refs.content.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
          const drawerOpen = this.drawerOpen
          const drawerWidth = drawerOpen ? DRAWER_WIDTH : 0

          let left = margin + drawerWidth
          let top = margin
          let width = defaultWidth
          let height = defaultHeight
          let maxAttempts = 100

          while (maxAttempts > 0 && this.windows.some(w => this.isOverlapping(left, top, width, height, w.position))) {
            left += margin
            top += margin

            if (left + width > containerRect.width) {
              left = margin + drawerWidth
            }
            if (top + height > containerRect.height) {
              top = margin
            }

            maxAttempts--
          }

          if (maxAttempts === 0) {
            let minOverlap = Number.MAX_VALUE
            let bestPosition = { left, top, width, height }

            for (let i = 0; i < containerRect.width - width; i += margin) {
              for (let j = 0; j < containerRect.height - height; j += margin) {
                let overlap = this.calculateTotalOverlap(i, j, width, height)
                if (overlap < minOverlap) {
                  minOverlap = overlap
                  bestPosition = { left: i + drawerWidth, top: j, width, height }
                }
              }
            }

            return bestPosition
          }

          return { left, top, width, height }
        },
        adjustWindowPositionsForDrawer(newDrawerOpen, oldDrawerOpen) {
          const drawerWidth = newDrawerOpen ? DRAWER_WIDTH : 0
          this.windows.forEach(window => {
            const windowRef = this.$refs[`window-${window.id}`][0]
            if (windowRef) {
              if (newDrawerOpen && windowRef.offsetLeft < drawerWidth) {
                windowRef.style.left = `${drawerWidth}px`
              }
              if (!newDrawerOpen && windowRef.offsetLeft < DRAWER_WIDTH) {
                windowRef.style.left = `${windowRef.offsetLeft - DRAWER_WIDTH}px`
              }
            }
          })
        },
        isOverlapping(left, top, width, height, position) {
          return !(
            left + width < position.left ||
            left > position.left + position.width ||
            top + height < position.top ||
            top > position.top + position.height
          )
        },
        calculateTotalOverlap(left, top, width, height) {
          let totalOverlap = 0
          this.windows.forEach(w => {
            totalOverlap += this.calculateOverlap(left, top, width, height, w.position)
          })
          return totalOverlap
        },
        calculateOverlap(left, top, width, height, position) {
          const x_overlap = Math.max(0, Math.min(left + width, position.left + position.width) - Math.max(left, position.left))
          const y_overlap = Math.max(0, Math.min(top + height, position.top + position.height) - Math.max(top, position.top))
          return x_overlap * y_overlap
        }
      },
      computed: {
        contentClasses() {
          return {
            'drawer-open': this.mdAndUp && this.drawerOpen
          }
        },
        topics() {
          return Object.fromEntries(this.brokers.flatMap(broker => broker.topics.map(topic => [`${broker.name}/${topic.name}`, topic])))
        }
      },
      template: `
        <div>
          <v-navigation-drawer
            app
            v-model="drawerOpen"
          >
            <div class="drawer-content">
              <tree-node 
                v-for="item in treeData" 
                :key="item.id" 
                :node="item" 
                :path="item.id" 
                :checkedPaths="checkedPaths"
                :topics="topics"
                :is-root="item.url !== ''"
                @select="updateSelectedPaths" 
              />
            </div>
          </v-navigation-drawer>
          <div :class="['content', contentClasses]" ref="content">
            <draggable-window
              v-for="window in windows"
              :key="window.id"
              :ref="'window-' + window.id"
              :title="window.title"
              :window-id="window.id"
              :window-z-index="getWindowZIndex(window.id)"
              :position="window.position"
              :drawer-open="drawerOpen"
              @focus="handleWindowFocus"
              @close="closeWindow"
              @minimize="minimizeWindow"
              @maximize="maximizeWindow"
            />
          </div>
        </div>
      `
    })

    const DashboardApp = defineComponent({
      components: { DashboardView },
      data() {
        return {
          currentTab: 1,
          tabCounter: 1,
          tabs: [
            { id: 1, name: 'View 1', drawerOpen: true, lastDrawerState: true, brokers: [] }
          ],
          dialog: false,
          newTabName: ''
        }
      },
      methods: {
        setCurrentTab(tabId) {
          this.tabs.forEach(tab => {
            if (tab.id === tabId) {
              tab.drawerOpen = tab.lastDrawerState
            } else {
              tab.drawerOpen = false
            }
          })
          this.currentTab = tabId
          this.newTabName = this.tabs.find(tab => tab.id === tabId).name
        },
        toggleDrawer() {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          currentTab.drawerOpen = !currentTab.drawerOpen
          currentTab.lastDrawerState = currentTab.drawerOpen
        },
        addNewTab() {
          this.tabCounter++
          const newTab = { id: Date.now(), name: `View ${this.tabCounter}`, drawerOpen: true, lastDrawerState: true, brokers: [] }
          this.tabs.push(newTab)
          this.setCurrentTab(newTab.id)
        },
        async closeTab(tabId) {
          const tabIdx = this.tabs.findIndex(tab => tab.id === tabId)
          if (tabIdx > -1) {
            const tab = this.tabs[tabIdx]
            for (const broker of tab.brokers) {
              if (broker.imageStream) {
                await broker.imageStream.stop()
              }
            }
            this.tabs.splice(tabIdx, 1)
            if (this.currentTab === tabId) {
              this.currentTab = this.tabs.length ? this.tabs[0].id : ''
            }
          }
        },
        openDialog() {
          this.dialog = true
          this.newTabName = this.tabs.find(tab => tab.id === this.currentTab).name
        },
        addTopic(brokerIndex) {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          currentTab.brokers[brokerIndex].topics.push({ name: '', type: 'text' })
        },
        addBroker() {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          currentTab.brokers.push({ name: '', url: '', topics: [], isRunning: false, imageStream: null, client: null })
        },
        renameCurrentTab(event) {
          const newName = event.target.value.trim()
          if (newName !== '' && !this.tabs.find(t => t.name === newName)) {
            const tab = this.tabs.find(tab => tab.id === this.currentTab)
            if (tab) {
              tab.name = newName
            }
          }
        },
        moveBrokerUp(brokerIndex) {
          if (brokerIndex > 0) {
            const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
            const temp = currentTab.brokers[brokerIndex]
            currentTab.brokers[brokerIndex] = currentTab.brokers[brokerIndex - 1]
            currentTab.brokers[brokerIndex - 1] = temp
          }
        },
        moveBrokerDown(brokerIndex) {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          if (brokerIndex < currentTab.brokers.length - 1) {
            const temp = currentTab.brokers[brokerIndex]
            currentTab.brokers[brokerIndex] = currentTab.brokers[brokerIndex + 1]
            currentTab.brokers[brokerIndex + 1] = temp
          }
        },
        moveTopicUp(brokerIndex, topicIndex) {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          const broker = currentTab.brokers[brokerIndex]
          if (topicIndex > 0) {
            const temp = broker.topics[topicIndex]
            broker.topics[topicIndex] = broker.topics[topicIndex - 1]
            broker.topics[topicIndex - 1] = temp
          }
        },
        moveTopicDown(brokerIndex, topicIndex) {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          const broker = currentTab.brokers[brokerIndex]
          if (topicIndex < broker.topics.length - 1) {
            const temp = broker.topics[topicIndex]
            broker.topics[topicIndex] = broker.topics[topicIndex + 1]
            broker.topics[topicIndex + 1] = temp
          }
        },
        validateBrokerName(brokerIndex) {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          const broker = currentTab.brokers[brokerIndex]
          if (broker.name.includes('/')) {
            broker.name = broker.name.replace(/\//g, '')
          }
        },
        deleteBroker(brokerIndex) {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          currentTab.brokers.splice(brokerIndex, 1)
        },
        deleteTopic(brokerIndex, topicIndex) {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          const broker = currentTab.brokers[brokerIndex]
          broker.topics.splice(topicIndex, 1)
        },
        async importView(event) {
          const file = event.target.files[0]
          if (file) {
            const reader = new FileReader()
            reader.onload = (e) => {
              try {
                const importedData = JSON.parse(e.target.result)
                const newTab = {
                  id: Date.now(),
                  name: importedData.name,
                  drawerOpen: true,
                  lastDrawerState: true,
                  brokers: importedData.brokers
                }
                this.tabs.push(newTab)
                this.setCurrentTab(newTab.id)
              } catch (error) {
                console.error('Error importing view:', error)
              }
            }
            reader.readAsText(file)
          }
        },
        async exportView() {
          const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
          const exportData = {
            name: currentTab.name,
            brokers: currentTab.brokers.map(broker => ({
              name: broker.name,
              url: broker.url,
              topics: broker.topics
            }))
          }
          const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' })
          const url = URL.createObjectURL(blob)
          const a = document.createElement('a')
          a.href = url
          a.download = `${currentTab.name}.json`
          a.click()
          URL.revokeObjectURL(url)
        },
        async importViewReplace(event) {
          const file = event.target.files[0]
          if (file) {
            const reader = new FileReader()
            reader.onload = (e) => {
              try {
                const importedData = JSON.parse(e.target.result)
                const currentTab = this.tabs.find(tab => tab.id === this.currentTab)
                currentTab.name = importedData.name
                this.newTabName = currentTab.name
                currentTab.brokers = importedData.brokers
              } catch (error) {
                console.error('Error importing view:', error)
              }
            }
            reader.readAsText(file)
          }
        }
      },
      mounted() {
        const el = this.$refs.tabContainer
        new Sortable(el, {
          animation: 150
        })
      },
      template: `
        <v-app>
          <v-app-bar app dense height="48" color="#333">
            <v-app-bar-nav-icon @click="toggleDrawer" style="color: white;"></v-app-bar-nav-icon>
            <div ref="tabContainer" style="display: flex; align-items: center;">
              <v-btn
                v-for="tab in tabs"
                :key="tab.id"
                text
                @click="setCurrentTab(tab.id)"
                :class="['tab-button', { 'active': currentTab === tab.id }]"
              >
                {{ tab.name }}
                <v-icon small class="tab-close" @click.stop="closeTab(tab.id)">mdi-close</v-icon>
              </v-btn>
            </div>
            <v-btn icon @click="addNewTab" style="color: white;">
              <v-icon>mdi-plus</v-icon>
            </v-btn>
            <v-spacer></v-spacer>
            <v-menu>
              <template v-slot:activator="{ props }">
                <v-btn icon="mdi-dots-vertical" v-bind="props" style="color: white;"></v-btn>
              </template>
              <v-list>
                <v-list-item @click="openDialog">
                  <v-list-item-title>View Settings</v-list-item-title>
                </v-list-item>
                <v-list-item @click="exportView">
                  <v-list-item-title>Export View</v-list-item-title>
                </v-list-item>
                <v-list-item>
                  <v-list-item-title>
                    <label for="import-file" style="cursor: pointer;">Import View</label>
                    <input type="file" id="import-file" @change="importView" style="display: none;" />
                  </v-list-item-title>
                </v-list-item>
              </v-list>
            </v-menu>
          </v-app-bar>
          <v-dialog v-model="dialog" max-width="800px">
            <v-card>
              <v-card-title>View Settings</v-card-title>
              <v-card-text>
                <v-container>
                  <v-row>
                    <v-col cols="12">
                      <v-text-field
                        v-model="newTabName"
                        label="Rename Tab"
                        @input="renameCurrentTab"
                      ></v-text-field>
                    </v-col>
                  </v-row>
                  <v-row v-for="(broker, index) in tabs.find(tab => tab.id === currentTab).brokers" :key="index">
                    <v-col cols="12">
                      <v-row align="center">
                        <v-col cols="8">
                          <v-text-field
                            v-model="broker.name"
                            label="Broker Name"
                            :rules="[v => v && !v.includes('/') || 'Broker name cannot contain /']"
                            @input="validateBrokerName(index)"
                          ></v-text-field>
                          <v-text-field v-model="broker.url" label="Broker URL"></v-text-field>
                        </v-col>
                        <v-col cols="4" class="topic-actions" style="text-align: right;">
                          <v-btn icon @click="moveBrokerUp(index)" variant="plain">
                            <v-icon>mdi-arrow-up</v-icon>
                          </v-btn>
                          <v-btn icon @click="moveBrokerDown(index)" variant="plain">
                            <v-icon>mdi-arrow-down</v-icon>
                          </v-btn>
                          <v-btn icon @click="deleteBroker(index)" variant="plain">
                            <v-icon>mdi-delete</v-icon>
                          </v-btn>
                        </v-col>
                      </v-row>
                      <v-row v-for="(topic, tIndex) in broker.topics" :key="tIndex" align="center">
                        <v-col cols="6">
                          <v-text-field v-model="broker.topics[tIndex].name" label="Topic"></v-text-field>
                        </v-col>
                        <v-col cols="3">
                          <v-select v-model="broker.topics[tIndex].type" :items="['text', 'tensor', 'image']" label="Type"></v-select>
                        </v-col>
                        <v-col cols="3" class="topic-actions">
                          <v-btn icon @click="moveTopicUp(index, tIndex)" variant="plain">
                            <v-icon>mdi-arrow-up</v-icon>
                          </v-btn>
                          <v-btn icon @click="moveTopicDown(index, tIndex)" variant="plain">
                            <v-icon>mdi-arrow-down</v-icon>
                          </v-btn>
                          <v-btn icon @click="deleteTopic(index, tIndex)" variant="plain">
                            <v-icon>mdi-delete</v-icon>
                          </v-btn>
                        </v-col>
                      </v-row>
                      <v-row>
                        <v-col cols="12">
                          <v-btn @click="addTopic(index)">
                            <v-icon>mdi-plus</v-icon>
                            Add Topic
                          </v-btn>
                        </v-col>
                      </v-row>
                    </v-col>
                  </v-row>
                </v-container>
              </v-card-text>
              <v-card-actions>
                <v-btn @click="addBroker">
                  <v-icon>mdi-plus</v-icon>
                  Add Broker
                </v-btn>
                <v-spacer></v-spacer>
                <v-btn @click="exportView">
                  <v-icon>mdi-export</v-icon>
                  Export
                </v-btn>
                <v-btn @click="$refs.importReplaceInput.click()">
                  <v-icon>mdi-import</v-icon>
                  Import
                  <input type="file" @change="importViewReplace" style="display: none;" ref="importReplaceInput">
                </v-btn>
              </v-card-actions>
            </v-card>
          </v-dialog>
          <dashboard-view
            v-for="tab in tabs"
            :key="tab.id"
            :drawer-open="tab.drawerOpen"
            :brokers="tab.brokers"
            v-show="currentTab === tab.id"
          ></dashboard-view>
        </v-app>
      `
    })

    createApp(DashboardApp).use(vuetify).mount('#app')
  </script>
</body>

</html>
