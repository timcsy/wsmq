<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/vuetify@3.1.9/dist/vuetify.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.1.9/dist/vuetify.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }

    .content {
      padding: 8px;
      transition: margin-left 0.3s ease;
      min-height: 100vh;
      margin-top: 48px;
      position: relative;
    }

    .content.drawer-open {
      margin-left: 256px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      margin: 2px 0;
    }

    .checkbox-label input {
      margin-right: 8px;
    }

    .draggable-window {
      position: absolute;
      border: 1px solid #ccc;
      background: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      resize: both;
      overflow: auto;
      border-radius: 8px;
    }

    .window-title {
      background: linear-gradient(to bottom, #f0f0f0, #d0d0d0);
      color: black;
      padding: 8px;
      cursor: move;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      height: 28px;
      display: flex;
      align-items: center;
    }

    .window-content {
      padding: 8px;
      overflow: auto;
    }

    .drawer-content {
      padding: 8px;
      overflow: auto;
      flex-grow: 1;
    }

    .window-buttons {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-right: 16px;
    }

    .window-button {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .window-button i {
      font-size: 2px;
      color: black;
    }

    .window-button.close {
      background-color: #ff5f57;
    }

    .window-button.minimize {
      background-color: #ffbd2e;
    }

    .window-button.maximize {
      background-color: #28c840;
    }

    .tab-button {
      color: white;
      text-transform: none;
    }

    .tab-button.active {
      background-color: white;
      color: black;
    }
  </style>
</head>

<body>
  <div id="app"></div>

  <script>
    const { createApp, defineComponent, ref, onMounted, watch, nextTick } = Vue
    const { createVuetify, useDisplay } = Vuetify

    const vuetify = createVuetify()

    const TreeNode = defineComponent({
      name: 'TreeNode',
      props: {
        node: Object,
        path: String,
        checkedPaths: Array,
        topics: Object
      },
      data() {
        return {
          checked: false
        }
      },
      watch: {
        checked(newVal) {
          this.$emit('select', this.path, newVal)
        },
        checkedPaths: {
          handler(newVal) {
            this.checked = newVal.includes(this.path)
          },
          immediate: true
        }
      },
      methods: {
        handleChildSelect(childPath, checked) {
          this.$emit('select', childPath, checked)
        },
        toggleCheckbox(event) {
          this.checked = event.target.checked
        },
        isDisabled(path) {
          return !this.topics[path]
        }
      },
      template: `
        <div>
          <label class="checkbox-label">
            <input type="checkbox" :disabled="isDisabled(path)" v-model="checked" @change="toggleCheckbox">
            {{ node.name }}
          </label>
          <div v-if="node.children" style="margin-left: 16px;">
            <tree-node 
              v-for="child in node.children" 
              :key="child.id" 
              :node="child" 
              :path="path + '/' + child.name" 
              :checkedPaths="checkedPaths"
              :topics="topics"
              @select="handleChildSelect" 
            />
          </div>
        </div>
      `
    })

    const DraggableWindow = defineComponent({
      name: 'DraggableWindow',
      props: {
        title: String,
        content: String,
        windowId: String,
        windowZIndex: Number,
        position: Object
      },
      setup(props, { emit }) {
        const windowRef = ref(null)
        const maximized = ref(false)
        const minimized = ref(false)
        const originalSize = ref({})

        onMounted(() => {
          const el = windowRef.value
          el.style.left = `${props.position.left}px`
          el.style.top = `${props.position.top}px`

          let startX, startY, initialX, initialY

          const onMouseMove = (event) => {
            const dx = event.clientX - startX
            const dy = event.clientY - startY
            let newX = initialX + dx
            let newY = initialY + dy

            // Ensure the window doesn't overlap the toolbar or go out of bounds
            const parentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
            const elRect = el.getBoundingClientRect()
            const toolbarHeight = 48

            if (newY < 0) {
              newY = 0
            }
            if (newX < 0) {
              newX = 0
            }
            if (newX + elRect.width > parentRect.width) {
              newX = parentRect.width - elRect.width
            }
            if (newY + elRect.height > parentRect.height - toolbarHeight) {
              newY = parentRect.height - elRect.height - toolbarHeight
            }

            el.style.left = `${newX}px`
            el.style.top = `${newY}px`
          }

          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove)
            document.removeEventListener('mouseup', onMouseUp)
          }

          el.addEventListener('mousedown', (event) => {
            if (!event.target.classList.contains('window-title')) return

            startX = event.clientX
            startY = event.clientY
            initialX = el.offsetLeft
            initialY = el.offsetTop

            document.addEventListener('mousemove', onMouseMove)
            document.addEventListener('mouseup', onMouseUp)

            event.preventDefault()
          })

          el.addEventListener('mousedown', () => {
            emit('focus', props.windowId)
          })

          el.ondragstart = () => false

          // Set initial size based on content
          nextTick(() => {
            const contentEl = el.querySelector('.window-content')
            if (contentEl) {
              const contentRect = contentEl.getBoundingClientRect()
              const titleWidth = el.querySelector('.window-title div').offsetWidth
              const buttonsWidth = el.querySelector('.window-buttons').offsetWidth
              const minWidth = titleWidth + buttonsWidth + 32 // Add 12px to the calculated width
              el.style.width = `${Math.max(contentRect.width + 20, minWidth)}px`
              el.style.height = `${contentRect.height + 56}px` // 28px for title + 28px padding
              el.style.minWidth = `${minWidth}px`
              el.style.minHeight = '28px' // Minimum height to show the title bar
            }
          })
        })

        watch(() => props.windowZIndex, (newZIndex) => {
          windowRef.value.style.zIndex = newZIndex
        })

        const toggleMaximize = () => {
          const el = windowRef.value
          const contentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }

          if (maximized.value) {
            el.style.width = originalSize.value.width
            el.style.height = originalSize.value.height
            el.style.left = originalSize.value.left
            el.style.top = originalSize.value.top
          } else {
            originalSize.value = {
              width: el.style.width,
              height: el.style.height,
              left: el.style.left,
              top: el.style.top
            }

            el.style.width = `${contentRect.width}px`
            el.style.height = `${contentRect.height - 48}px`
            el.style.left = '0px'
            el.style.top = '0px'
          }

          maximized.value = !maximized.value
          emit('focus', props.windowId)
        }

        const toggleMinimize = () => {
          const el = windowRef.value

          if (minimized.value) {
            el.style.width = originalSize.value.width
            el.style.height = originalSize.value.height
            el.style.left = originalSize.value.left
            el.style.top = originalSize.value.top
          } else {
            originalSize.value = {
              width: el.style.width,
              height: el.style.height,
              left: el.style.left,
              top: el.style.top
            }
          }

          minimized.value = !minimized.value
          emit('focus', props.windowId)
        }

        const onResize = (entries) => {
          for (let entry of entries) {
            const el = entry.target
            const parentRect = el.parentElement ? el.parentElement.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }
            const toolbarHeight = 48

            if (el.offsetHeight + el.offsetTop > parentRect.height - toolbarHeight) {
              el.style.height = `${parentRect.height - toolbarHeight - el.offsetTop}px`
            }
          }
        }

        const resizeObserver = new ResizeObserver(onResize)

        onMounted(() => {
          const el = windowRef.value
          resizeObserver.observe(el)
        })

        return {
          windowRef,
          toggleMaximize,
          toggleMinimize,
          minimized,
          onResize
        }
      },
      methods: {
        closeWindow() {
          this.$emit('close', this.windowId)
        },
        minimizeWindow() {
          this.toggleMinimize()
          this.$emit('minimize', this.windowId)
        },
        maximizeWindow() {
          this.toggleMaximize()
        }
      },
      template: `
        <div v-show="!minimized" class="draggable-window" ref="windowRef" :style="{ zIndex: windowZIndex }">
          <div class="window-title">
            <div class="window-buttons">
              <div class="window-button close" @click="closeWindow"><i class="fas fa-times"></i></div>
              <div class="window-button minimize" @click="minimizeWindow"><i class="fas fa-minus"></i></div>
              <div class="window-button maximize" @click="maximizeWindow"><i class="fas fa-expand"></i></div>
            </div>
            <div>{{ title }}</div>
          </div>
          <div class="window-content" v-html="content"></div>
        </div>
      `
    })

    const DashboardView = defineComponent({
      components: {
        'tree-node': TreeNode,
        'draggable-window': DraggableWindow
      },
      props: {
        drawerOpen: Boolean,
        topics: Object
      },
      setup(props) {
        const { mdAndUp, mdAndDown } = useDisplay()
        const drawerOpen = ref(props.drawerOpen)

        watch(() => props.drawerOpen, (newVal) => {
          drawerOpen.value = newVal
        })

        return {
          mdAndUp,
          mdAndDown,
          drawerOpen
        }
      },
      data() {
        return {
          treeData: [],
          windows: [],
          windowOrder: [],
          checkedPaths: []
        }
      },
      watch: {
        topics: {
          handler(newTopics) {
            this.updateTreeData(newTopics)
          },
          immediate: true
        }
      },
      methods: {
        updateTreeData(topics) {
          const tree = {}
          Object.keys(topics).forEach(topic => {
            const parts = topic.split('/')
            let current = tree
            parts.forEach(part => {
              if (!current[part]) {
                current[part] = { children: {} }
              }
              current = current[part].children
            })
          })
          this.treeData = this.convertTreeData(tree)
        },
        convertTreeData(tree, parentPath = '') {
          return Object.keys(tree).map(key => {
            const fullPath = parentPath ? `${parentPath}/${key}` : key
            return {
              id: fullPath,
              name: key,
              children: this.convertTreeData(tree[key].children, fullPath)
            }
          })
        },
        updateSelectedPaths(path, checked) {
          const windowId = path
          const { left, top, width, height } = this.findNewWindowPosition()
          if (checked) {
            if (!this.checkedPaths.includes(path)) {
              this.checkedPaths.push(path)
            }
            const existingWindow = this.windows.find(w => w.id === windowId)
            if (existingWindow) {
              this.$refs[`window-${windowId}`][0].toggleMinimize()
            } else {
              this.windows.push({
                id: windowId,
                title: path,
                content: this.topics[path] || 'No content',
                minimized: false,
                position: { left, top, width, height }
              })
              this.windowOrder.push(windowId)
            }
            this.handleWindowFocus(windowId)
          } else {
            this.checkedPaths = this.checkedPaths.filter(p => p !== path)
            const windowToMinimize = this.$refs[`window-${windowId}`][0]
            if (windowToMinimize) {
              windowToMinimize.toggleMinimize()
            }
          }
        },
        getNodePath(node) {
          const path = []
          let current = node
          while (current) {
            path.unshift(current.name)
            current = this.findParent(this.treeData, current)
          }
          return path.join('/')
        },
        findParent(nodes, target) {
          for (let node of nodes) {
            if (node.children && node.children.includes(target)) {
              return node
            }
            if (node.children) {
              const parent = this.findParent(node.children, target)
              if (parent) {
                return parent
              }
            }
          }
          return null
        },
        handleWindowFocus(windowId) {
          this.windowOrder = this.windowOrder.filter(id => id !== windowId)
          this.windowOrder.push(windowId)
        },
        getWindowZIndex(windowId) {
          return this.windowOrder.indexOf(windowId) + 1000
        },
        closeWindow(windowId) {
          this.windows = this.windows.filter(w => w.id !== windowId)
          this.windowOrder = this.windowOrder.filter(id => id !== windowId)
          this.checkedPaths = this.checkedPaths.filter(path => path !== windowId)
        },
        minimizeWindow(windowId) {
          this.$refs[`window-${windowId}`][0].toggleMinimize()
          this.checkedPaths = this.checkedPaths.filter(path => path !== windowId)
        },
        maximizeWindow(windowId) {
          this.$refs[`window-${windowId}`][0].toggleMaximize()
        },
        findNewWindowPosition() {
          const margin = 10
          const defaultWidth = 300
          const defaultHeight = 200
          const containerRect = this.$refs.content ? this.$refs.content.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight }

          let left = margin
          let top = margin
          let width = defaultWidth
          let height = defaultHeight
          let maxAttempts = 100 // Maximum attempts to avoid infinite loop

          while (maxAttempts > 0 && this.windows.some(w => this.isOverlapping(left, top, width, height, w.position))) {
            left += margin
            top += margin

            if (left + width > containerRect.width) {
              left = margin
            }
            if (top + height > containerRect.height) {
              top = margin
            }

            maxAttempts--
          }

          // If no suitable position found, choose the one with the least overlap
          if (maxAttempts === 0) {
            let minOverlap = Number.MAX_VALUE
            let bestPosition = { left, top, width, height }

            for (let i = 0; i < containerRect.width - width; i += margin) {
              for (let j = 0; j < containerRect.height - height; j += margin) {
                let overlap = this.calculateTotalOverlap(i, j, width, height)
                if (overlap < minOverlap) {
                  minOverlap = overlap
                  bestPosition = { left: i, top: j, width, height }
                }
              }
            }

            return bestPosition
          }

          return { left, top, width, height }
        },
        isOverlapping(left, top, width, height, position) {
          return !(
            left + width < position.left ||
            left > position.left + position.width ||
            top + height < position.top ||
            top > position.top + position.height
          )
        },
        calculateTotalOverlap(left, top, width, height) {
          let totalOverlap = 0
          this.windows.forEach(w => {
            totalOverlap += this.calculateOverlap(left, top, width, height, w.position)
          })
          return totalOverlap
        },
        calculateOverlap(left, top, width, height, position) {
          const x_overlap = Math.max(0, Math.min(left + width, position.left + position.width) - Math.max(left, position.left))
          const y_overlap = Math.max(0, Math.min(top + height, position.top + position.height) - Math.max(top, position.top))
          return x_overlap * y_overlap
        }
      },
      computed: {
        contentClasses() {
          return {
            'drawer-open': this.mdAndUp && this.drawerOpen
          }
        }
      },
      template: `
        <div>
          <v-navigation-drawer
            app
            v-model="drawerOpen"
          >
            <div class="drawer-content">
              <tree-node 
                v-for="item in treeData" 
                :key="item.id" 
                :node="item" 
                :path="item.id" 
                :checkedPaths="checkedPaths"
                :topics="topics"
                @select="updateSelectedPaths" 
              />
            </div>
          </v-navigation-drawer>
          <div :class="['content', contentClasses]" ref="content">
            <draggable-window
              v-for="window in windows"
              :key="window.id"
              :ref="'window-' + window.id"
              :title="window.title"
              :content="window.content"
              :window-id="window.id"
              :window-z-index="getWindowZIndex(window.id)"
              :position="window.position"
              @focus="handleWindowFocus"
              @close="closeWindow"
              @minimize="minimizeWindow"
              @maximize="maximizeWindow"
            />
          </div>
        </div>
      `
    })

    createApp({
      components: { DashboardView },
      data() {
        return {
          currentTab: 'tab1',
          tabs: [
            { name: 'tab1', drawerOpen: true, lastDrawerState: true, topics: { 'foo/bar': '<p>Bar Content</p>', 'foo/dev': '<p>Dev Content</p>' } },
            { name: 'tab2', drawerOpen: false, lastDrawerState: true, topics: { 'topic2/subtopic1': '<p>Subtopic 1 Content</p>', 'topic2/subtopic2': '<p>Subtopic 2 Content</p>' } },
            { name: 'tab3', drawerOpen: false, lastDrawerState: true, topics: { 'topic3/subtopic1': '<p>Subtopic 1 Content</p>', 'topic3/subtopic2': '<p>Subtopic 2 Content</p>' } }
          ]
        }
      },
      methods: {
        setCurrentTab(tabName) {
          this.tabs.forEach(tab => {
            if (tab.name === tabName) {
              tab.drawerOpen = tab.lastDrawerState
            } else {
              tab.drawerOpen = false
            }
          })
          this.currentTab = tabName
        },
        toggleDrawer() {
          const currentTab = this.tabs.find(tab => tab.name === this.currentTab)
          currentTab.drawerOpen = !currentTab.drawerOpen
          currentTab.lastDrawerState = currentTab.drawerOpen
        }
      },
      template: `
        <v-app>
          <v-app-bar app dense height="48" color="#333">
            <v-app-bar-nav-icon @click="toggleDrawer" style="color: white;"></v-app-bar-nav-icon>
            <div style="display: flex;">
              <v-btn
                v-for="tab in tabs"
                :key="tab.name"
                text
                @click="setCurrentTab(tab.name)"
                :class="['tab-button', { 'active': currentTab === tab.name }]"
              >
                {{ tab.name }}
              </v-btn>
            </div>
          </v-app-bar>
          <dashboard-view
            v-for="tab in tabs"
            :key="tab.name"
            :drawer-open="tab.drawerOpen"
            :topics="tab.topics"
            v-show="currentTab === tab.name"
          ></dashboard-view>
        </v-app>
      `
    }).use(vuetify).mount('#app')
  </script>
</body>

</html>
